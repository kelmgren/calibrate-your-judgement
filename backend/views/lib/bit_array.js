// Generated by CoffeeScript 1.10.0
(function() {
  var Base64, Base64Utilities, BitArray;

  BitArray = (function() {
    function BitArray(options) {
      this._validate_length(options);
      this.base64 = this._load_base64(options);
    }

    BitArray.prototype.bits = function() {
      return Base64Utilities.to_binary(this.base64.base64);
    };

    BitArray.prototype.to_base64 = function() {
      return this.base64.base64;
    };

    BitArray.prototype.value = function(arg) {
      var position, value;
      position = arg.position, value = arg.value;
      if (value == null) {
        return this.base64.get_value(position);
      }
      this._validate_input(value);
      return this.base64.set_value({
        position: position,
        value: Number(value)
      });
    };

    BitArray.prototype._load_base64 = function(options) {
      return new Base64(this._base64_string(options));
    };

    BitArray.prototype._base64_string = function(arg) {
      var base64, bits, size;
      base64 = arg.base64, bits = arg.bits, size = arg.size;
      return base64 || Base64Utilities.from_binary(bits || this._empty_bit_array_of_size(size));
    };

    BitArray.prototype._empty_bit_array_of_size = function(size) {
      var i, index, ref, results;
      results = [];
      for (index = i = 1, ref = size; 1 <= ref ? i <= ref : i >= ref; index = 1 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    };

    BitArray.prototype._validate_input = function(value) {
      if (value === true || value === false || value === 0 || value === 1) {
        return;
      }
      throw 'Input value must be a binary value (0, 1, or a boolean)';
    };

    BitArray.prototype._validate_length = function(options) {
      if (options.base64 || this._even_number_of_bits(options)) {
        return;
      }
      throw new Error('BitArray must be initialized with an even number of bits');
    };

    BitArray.prototype._even_number_of_bits = function(arg) {
      var bits, size;
      bits = arg.bits, size = arg.size;
      return ((bits != null ? bits.length : void 0) || size) % 2 === 0;
    };

    return BitArray;

  })();

  Base64 = (function() {
    function Base64(base641) {
      this.base64 = base641;
    }

    Base64.prototype.get_value = function(position) {
      return this._value_at(this._base64_coordinates(position));
    };

    Base64.prototype.set_value = function(arg) {
      var position, value;
      position = arg.position, value = arg.value;
      return this._set_value_at({
        coordinates: this._base64_coordinates(position),
        value: value
      });
    };

    Base64.prototype._set_value_at = function(arg) {
      var coordinates, value;
      coordinates = arg.coordinates, value = arg.value;
      return this._replace_character({
        index: coordinates.byte,
        character: this._updated_base64_byte(coordinates, value)
      });
    };

    Base64.prototype._updated_base64_byte = function(arg, value) {
      var binary_byte, bit, byte;
      byte = arg.byte, bit = arg.bit;
      binary_byte = this._binary_byte_at(byte);
      binary_byte[bit] = value;
      return Base64Utilities.from_binary(binary_byte);
    };

    Base64.prototype._replace_character = function(arg) {
      var character, index;
      index = arg.index, character = arg.character;
      return this.base64 = this.base64.substring(0, index) + character + this.base64.substring(index + 1);
    };

    Base64.prototype._value_at = function(arg) {
      var bit, byte;
      byte = arg.byte, bit = arg.bit;
      return this._binary_byte_at(byte)[bit];
    };

    Base64.prototype._binary_byte_at = function(byte_index) {
      return Base64Utilities.to_binary(this.base64[byte_index]);
    };

    Base64.prototype._base64_coordinates = function(position) {
      return {
        byte: Math.floor(position / 6),
        bit: position % 6
      };
    };

    return Base64;

  })();

  Base64Utilities = (function() {
    var BASE_64_CHARACTERS;

    function Base64Utilities() {}

    BASE_64_CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    Base64Utilities.to_binary = function(base64) {
      return new Base64Utilities().to_binary(base64);
    };

    Base64Utilities.from_binary = function(bit_array) {
      return new Base64Utilities().from_binary(bit_array);
    };

    Base64Utilities.prototype.to_binary = function(base64) {
      var character, i, len, padding, ref;
      if (!base64) {
        return;
      }
      this.bit_array = [];
      ref = this._separate_padding(base64), base64 = ref[0], padding = ref[1];
      for (i = 0, len = base64.length; i < len; i++) {
        character = base64[i];
        this._add_bits_from_base64(character);
      }
      return this._without_padded_bits(this.bit_array, padding);
    };

    Base64Utilities.prototype.from_binary = function(bit_array1) {
      var base64, chunk, chunks, decimal, i, len, padding;
      this.bit_array = bit_array1;
      base64 = '';
      chunks = this._chunks_of_six();
      padding = this._padding_for(chunks);
      this._pad(chunks);
      for (i = 0, len = chunks.length; i < len; i++) {
        chunk = chunks[i];
        decimal = this.to_decimal(chunk);
        base64 = base64 + BASE_64_CHARACTERS[decimal];
      }
      return base64 + padding;
    };

    Base64Utilities.prototype._padding_for = function(chunks) {
      var last_chunk;
      last_chunk = chunks[chunks.length - 1];
      switch (last_chunk.length) {
        case 6:
          return '';
        case 4:
          return '=';
        case 2:
          return '==';
      }
    };

    Base64Utilities.prototype._pad = function(chunks) {
      var last_chunk;
      last_chunk = chunks[chunks.length - 1];
      last_chunk = (last_chunk + '0000').substring(0, 6);
      chunks[chunks.length - 1] = last_chunk;
      return chunks;
    };

    Base64Utilities.prototype._chunks_of_six = function() {
      var chunks, i, index, ref;
      chunks = [];
      for (index = i = 0, ref = this.bit_array.length / 6; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        chunks.push(this._chunk_number(index));
      }
      return chunks;
    };

    Base64Utilities.prototype._chunk_number = function(index) {
      return this.bit_array.slice(index * 6, (index + 1) * 6).join('');
    };

    Base64Utilities.prototype.to_decimal = function(chunk) {
      return parseInt(chunk, 2);
    };

    Base64Utilities.prototype._without_padded_bits = function(bits, padding) {
      if (!(padding.length > 0)) {
        return bits;
      }
      return bits.slice(0, -2 * padding.length);
    };

    Base64Utilities.prototype._separate_padding = function(base64) {
      var padding;
      padding = base64.match('=*$')[0];
      base64 = this._without_padding(base64, padding);
      return [base64, padding];
    };

    Base64Utilities.prototype._without_padding = function(base64, padding) {
      if (!(padding.length > 0)) {
        return base64;
      }
      return base64.slice(0, -1 * padding.length);
    };

    Base64Utilities.prototype._add_bits_from_base64 = function(character) {
      var binary, decimal;
      decimal = this._decimal_from_base64(character);
      binary = this._binary_from_decimal(decimal);
      return this.bit_array = this.bit_array.concat(binary);
    };

    Base64Utilities.prototype._binary_from_decimal = function(decimal) {
      var binary_characters, char, i, len, results;
      binary_characters = this._padded_binary_string(decimal).split('');
      results = [];
      for (i = 0, len = binary_characters.length; i < len; i++) {
        char = binary_characters[i];
        results.push(Number(char));
      }
      return results;
    };

    Base64Utilities.prototype._padded_binary_string = function(decimal) {
      return ('000000' + decimal.toString(2)).slice(-6);
    };

    Base64Utilities.prototype._decimal_from_base64 = function(character) {
      return BASE_64_CHARACTERS.indexOf(character);
    };

    return Base64Utilities;

  })();

  module.exports = BitArray;

}).call(this);
